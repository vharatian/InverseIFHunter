/**
 * Model Hunter - Frontend Application
 * 
 * Handles:
 * - Theme toggling
 * - Notebook upload/fetch
 * - Hunt configuration
 * - SSE progress streaming
 * - Results display
 *
 * Modules extracted (loaded via module bridge in index.html):
 * - modules/config.js   ‚Äî constants, provider models, tips
 * - modules/utils.js    ‚Äî helper functions
 * - modules/types.js    ‚Äî JSDoc type definitions
 * - modules/state.js    ‚Äî application state, resetTurnState, getCumulativeStats
 * - modules/api.js      ‚Äî version check, showUpdatePrompt, showAppModal
 * - modules/auth.js     ‚Äî trainer registration, heartbeat
 */

// ============== Module References ==============
// These are loaded by the ES6 module bridge in index.html and exposed on window.*
// We create local const references so existing code works unchanged.
const state = window.state;
const checkVersion = window.checkVersion;
const hasPendingUpdate = window.hasPendingUpdate;
const showUpdatePrompt = window.showUpdatePrompt;
const showAppModal = window.showAppModal;

// ============== Provider Models ==============
// PROVIDER_MODELS moved to config.js
const PROVIDER_MODELS = window.PROVIDER_MODELS;


// ============== Trainer Registration ==============
// Moved to modules/auth.js ‚Äî functions exposed via window.* bridge
const getTrainerInfo = window.getTrainerInfo;
const isTrainerRegistered = window.isTrainerRegistered;
const showTrainerIdentity = window.showTrainerIdentity;
const hideTrainerRegistration = window.hideTrainerRegistration;
const showTrainerRegistration = window.showTrainerRegistration;
const registerTrainer = window.registerTrainer;
const initTrainerRegistration = window.initTrainerRegistration;
const startHeartbeat = window.startHeartbeat;
const stopHeartbeat = window.stopHeartbeat;


// ============== DOM Elements ==============
// Moved to modules/dom.js ‚Äî exposed via window.* bridge
const elements = window.elements;


// ============== Hunt Limit Constants ==============
// Constants moved to config.js
const MAX_HUNTS_PER_NOTEBOOK = window.MAX_HUNTS_PER_NOTEBOOK;
const HUNT_COUNT_STORAGE_PREFIX = window.HUNT_COUNT_STORAGE_PREFIX;
const MIN_EXPLANATION_WORDS = window.MIN_EXPLANATION_WORDS;












// ============== Turn Color System ==============
// TURN_COLORS moved to config.js


// getCumulativeStats() and resetTurnState() moved to modules/state.js
const getCumulativeStats = window.getCumulativeStats;
const resetTurnState = window.resetTurnState;


// ================================================================
// SHARED HELPERS ‚Äî Extracted from duplicate patterns
// ================================================================

// Helpers moved to utils.js

// ================================================================
// INSIGHT TIPS ‚Äî Data-driven contextual tips from ML analysis
// Source: 46,686 hunts across 741 trainers
// ================================================================
// INSIGHT_TIPS moved to config.js
// Tip rendering functions moved to utils.js
const INSIGHT_TIPS = window.INSIGHT_TIPS;


// ============== Original Notebook JSON Update Helper ==============
// Moved to modules/notebook.js
const updateOriginalNotebookWithCell = window.updateOriginalNotebookWithCell;

// ============== Hunt Limits + Config + Execution ==============
// Moved to modules/hunt.js ‚Äî exposed via window.* bridge
const incrementHuntCount = window.incrementHuntCount;
const canStartMoreHunts = window.canStartMoreHunts;
const getRemainingHunts = window.getRemainingHunts;
const updateHuntLimitUI = window.updateHuntLimitUI;
const showHuntLimitReachedError = window.showHuntLimitReachedError;
const getConfig = window.getConfig;
const startHunt = window.startHunt;
const initProgressUI = window.initProgressUI;
const updateTableRow = window.updateTableRow;
const handleHuntProgress = window.handleHuntProgress;
const handleHuntResult = window.handleHuntResult;


// ============== Response Slideouts + Selection + Review ==============
// Moved to modules/results.js ‚Äî exposed via window.* bridge
const openResponseSlideout = window.openResponseSlideout;
const closeResponseSlideout = window.closeResponseSlideout;
const openSelectionDetailSlideout = window.openSelectionDetailSlideout;
const openGradingSlideout = window.openGradingSlideout;
const setupGradingSlideoutEvents = window.setupGradingSlideoutEvents;
const submitGradingReview = window.submitGradingReview;
const closeGradingSlideout = window.closeGradingSlideout;
const toggleSelectionResponse = window.toggleSelectionResponse;
const handleHuntComplete = window.handleHuntComplete;
const fetchAllResponses = window.fetchAllResponses;
const fetchAllResponsesAndShowSelection = window.fetchAllResponsesAndShowSelection;



// ============== Turn-Aware + Multi-Turn + Calibration ==============
// Moved to modules/multiturn.js ‚Äî exposed via window.* bridge
const activateTurnTab = window.activateTurnTab;
const renderJourneyBar = window.renderJourneyBar;
const renderConversationThread = window.renderConversationThread;
const updateTurnAwareUI = window.updateTurnAwareUI;
const showMultiTurnDecision = window.showMultiTurnDecision;
const renderTurnHistoryTabs = window.renderTurnHistoryTabs;
const renderTurnContent = window.renderTurnContent;
const handleMarkBreaking = window.handleMarkBreaking;
const handleContinueToNextTurn = window.handleContinueToNextTurn;
const selectGoodResponse = window.selectGoodResponse;
const showCalibrationPanel = window.showCalibrationPanel;
const hideCalibrationPanel = window.hideCalibrationPanel;
const calibrationGenerateOne = window.calibrationGenerateOne;
const calibrationJudge = window.calibrationJudge;
const initCalibrationListeners = window.initCalibrationListeners;
const startNextTurn = window.startNextTurn;
const initMultiTurnListeners = window.initMultiTurnListeners;



// ============== Selection + Review ==============
// Moved to modules/results.js ‚Äî exposed via window.* bridge
const displaySelectionCards = window.displaySelectionCards;
const refreshSelectionTable = window.refreshSelectionTable;
const toggleHuntSelection = window.toggleHuntSelection;
const toggleDetailsRow = window.toggleDetailsRow;
const updateSelectionCount = window.updateSelectionCount;
const confirmSelection = window.confirmSelection;
const displaySelectedForReview = window.displaySelectedForReview;
const disableSelectionCheckboxes = window.disableSelectionCheckboxes;
const enableSelectionCheckboxes = window.enableSelectionCheckboxes;
const updateReviewProgress = window.updateReviewProgress;
const revealLLMJudgments = window.revealLLMJudgments;
const displayBreakingResults = window.displayBreakingResults;
const createResultCard = window.createResultCard;
const createResultCardFull = window.createResultCardFull;
const handleHumanReview = window.handleHumanReview;
const submitHumanReview = window.submitHumanReview;
const revealLLMJudge = window.revealLLMJudge;
const checkAllReviewsComplete = window.checkAllReviewsComplete;



// ============== Export + Utilities ==============
// Moved to modules/results.js ‚Äî exposed via window.* bridge
const exportNotebook = window.exportNotebook;
const clearPreviousResults = window.clearPreviousResults;
const formatLLMCriteria = window.formatLLMCriteria;
const formatJudgeCriteriaDisplay = window.formatJudgeCriteriaDisplay;
// escapeHtml already from utils.js
const htmlToPlainText = window.htmlToPlainText;
const warmupConnections = window.warmupConnections;

// ============== Celebration Effects ==============
// Moved to modules/celebrations.js ‚Äî exposed via window.* bridge
const showToast = window.showToast;
const triggerColabConfetti = window.triggerColabConfetti;
const showNextBlindJudge = window.showNextBlindJudge;
const handleHumanJudgment = window.handleHumanJudgment;
const updateRowWithScore = window.updateRowWithScore;
const hideBlindJudgeModal = window.hideBlindJudgeModal;
const showFinalResults = window.showFinalResults;


// ============== Hunt Number Controls ==============

function initHuntNumberControls() {
    const numberInput = document.getElementById('parallelWorkers');
    const slider = document.getElementById('parallelWorkersSlider');
    const decreaseBtn = document.querySelector('.hunt-btn-decrease');
    const increaseBtn = document.querySelector('.hunt-btn-increase');
    const presetBtns = document.querySelectorAll('.preset-btn');
    
    if (!numberInput || !slider) return;
    
    // Function to update all controls to a value
    function updateValue(newValue) {
        const value = Math.max(1, Math.min(6, parseInt(newValue) || 4));
        
        numberInput.value = value;
        slider.value = value;
        
        // Update preset button states
        presetBtns.forEach(btn => {
            if (parseInt(btn.dataset.value) === value) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        
        // Update button states
        if (decreaseBtn) {
            decreaseBtn.disabled = value <= 1;
        }
        if (increaseBtn) {
            increaseBtn.disabled = value >= 6;
        }
    }
    
    // Sync number input -> slider
    numberInput.addEventListener('input', (e) => {
        updateValue(e.target.value);
    });
    
    // Sync slider -> number input
    slider.addEventListener('input', (e) => {
        updateValue(e.target.value);
    });
    
    // Decrease button
    if (decreaseBtn) {
        decreaseBtn.addEventListener('click', () => {
            const current = parseInt(numberInput.value) || 4;
            if (current > 1) {
                updateValue(current - 1);
            }
        });
    }
    
    // Increase button
    if (increaseBtn) {
        increaseBtn.addEventListener('click', () => {
            const current = parseInt(numberInput.value) || 4;
            if (current < 6) {
                updateValue(current + 1);
            }
        });
    }
    
    // Preset buttons
    presetBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            updateValue(btn.dataset.value);
        });
    });
    
    // Initialize state
    updateValue(numberInput.value);
}

// ============== Event Listeners ==============

function initEventListeners() {
    elements.themeToggle.addEventListener('click', toggleTheme);
    elements.startHuntBtn.addEventListener('click', startHunt);
    if (elements.saveDriveBtn) elements.saveDriveBtn.addEventListener('click', saveToDrive);
    
    // Metadata sidebar toggle
    if (elements.metadataToggleBtn) {
        elements.metadataToggleBtn.addEventListener('click', toggleMetadataSidebar);
    }
    
    // Clear results and reset when model changes
    // FIX 4: Only allow model change if not locked (not during/after hunt)
    if (elements.modelSelect) {
        elements.modelSelect.addEventListener('change', () => {
            // Check if model selection is locked
            if (elements.modelSelect.disabled) {
                showToast('Model selection is locked. Please refresh the page to change model.', 'warning');
                // Revert to previous value
                const previousModel = state.config.models?.[0] || 'qwen/qwen3-235b-a22b-thinking-2507';
                elements.modelSelect.value = previousModel;
                return;
            }
            
            // Clear previous results when model changes
            clearPreviousResults();
            state.modelMismatchWarning = false;
            showToast('Model changed. Previous results cleared.', 'info');
        });
    }
    
    // FIX 4: Prevent provider change if locked
    if (elements.providerSelect) {
        elements.providerSelect.addEventListener('change', () => {
            if (elements.providerSelect.disabled) {
                showToast('Provider selection is locked. Please refresh the page to change provider.', 'warning');
                // Revert to previous value
                const previousProvider = state.config.provider || 'openrouter';
                elements.providerSelect.value = previousProvider;
                return;
            }
            // Update model options when provider changes
            updateModelOptions();
        });
    }
    
    // Blind judging buttons
    elements.humanJudgePass?.addEventListener('click', () => handleHumanJudgment(1));
    elements.humanJudgeFail?.addEventListener('click', () => handleHumanJudgment(0));
    elements.humanJudgeSkip?.addEventListener('click', () => {
        // Skip without recording judgment, but still reveal LLM score
        handleHumanJudgment(null);
    });
    elements.nextHuntBtn?.addEventListener('click', showNextBlindJudge);
    
    // Judge reference response button (for other tabs)
    elements.judgeReferenceBtn?.addEventListener('click', judgeReferenceResponse);
    
    // Judge button next to Start Hunt button
    elements.judgeBeforeHuntBtn?.addEventListener('click', judgeReferenceResponse);
    
    // Save response button (Response tab)
    elements.saveResponseBtn?.addEventListener('click', saveResponseOnly);
    
    // NEW: Selection and Reveal buttons
    elements.confirmSelectionBtn?.addEventListener('click', confirmSelection);
    elements.revealLLMBtn?.addEventListener('click', revealLLMJudgments);
    
    // Response slide-out panel events
    elements.slideoutCloseBtn?.addEventListener('click', closeResponseSlideout);
    elements.responseSlideoutBackdrop?.addEventListener('click', closeResponseSlideout);
    
    // Grading slide-out panel events
    document.getElementById('gradingSlideoutCloseBtn')?.addEventListener('click', closeGradingSlideout);
    document.getElementById('gradingSlideoutBackdrop')?.addEventListener('click', closeGradingSlideout);
    
    // Close slide-outs with Escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (elements.responseSlideout?.classList.contains('open')) {
                closeResponseSlideout();
            }
            if (document.getElementById('gradingSlideout')?.classList.contains('open')) {
                closeGradingSlideout();
            }
        }
    });
    
    // Initialize slideout resize functionality
    initSlideoutResize();
}

// ============== Slideout Resize Functionality ==============

function initSlideoutResize() {
    // Response slideout resize
    const responseSlideout = document.getElementById('responseSlideout');
    const responseResizeHandle = document.getElementById('responseSlideoutResizeHandle');
    if (responseSlideout && responseResizeHandle) {
        setupSlideoutResize(responseSlideout, responseResizeHandle, 300, window.innerWidth * 0.95);
    }
    
    // Grading slideout resize
    const gradingSlideout = document.getElementById('gradingSlideout');
    const gradingResizeHandle = document.getElementById('gradingSlideoutResizeHandle');
    if (gradingSlideout && gradingResizeHandle) {
        setupSlideoutResize(gradingSlideout, gradingResizeHandle, 400, window.innerWidth * 0.95);
    }
}

function setupSlideoutResize(slideout, resizeHandle, minWidth, maxWidth) {
    let isResizing = false;
    let startX = 0;
    let startWidth = 0;
    
    // Mouse events
    resizeHandle.addEventListener('mousedown', startResize);
    
    // Touch events for mobile
    resizeHandle.addEventListener('touchstart', startResize, { passive: false });
    
    function startResize(e) {
        e.preventDefault();
        isResizing = true;
        
        // Get starting position (handle both mouse and touch)
        startX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        startWidth = slideout.offsetWidth;
        
        // Add resizing class to disable transitions
        slideout.classList.add('resizing');
        resizeHandle.classList.add('active');
        
        // Prevent text selection during resize
        document.body.style.userSelect = 'none';
        document.body.style.cursor = 'ew-resize';
        
        // Add move and end listeners
        document.addEventListener('mousemove', doResize);
        document.addEventListener('mouseup', stopResize);
        document.addEventListener('touchmove', doResize, { passive: false });
        document.addEventListener('touchend', stopResize);
    }
    
    function doResize(e) {
        if (!isResizing) return;
        e.preventDefault();
        
        // Get current position (handle both mouse and touch)
        const currentX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        
        // Calculate new width (dragging left increases width since panel is on the right)
        const deltaX = startX - currentX;
        let newWidth = startWidth + deltaX;
        
        // Clamp to min/max
        newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
        
        // Apply new width
        slideout.style.width = `${newWidth}px`;
    }
    
    function stopResize() {
        if (!isResizing) return;
        isResizing = false;
        
        // Remove resizing class
        slideout.classList.remove('resizing');
        resizeHandle.classList.remove('active');
        
        // Restore body styles
        document.body.style.userSelect = '';
        document.body.style.cursor = '';
        
        // Remove listeners
        document.removeEventListener('mousemove', doResize);
        document.removeEventListener('mouseup', stopResize);
        document.removeEventListener('touchmove', doResize);
        document.removeEventListener('touchend', stopResize);
        
        // Save the width to localStorage for persistence
        const slideoutId = slideout.id;
        if (slideoutId) {
            localStorage.setItem(`${slideoutId}Width`, slideout.style.width);
        }
    }
    
    // Restore saved width on page load
    const savedWidth = localStorage.getItem(`${slideout.id}Width`);
    if (savedWidth) {
        slideout.style.width = savedWidth;
    }
}

// ============== Metadata Sidebar Toggle ==============

function toggleMetadataSidebar() {
    if (!elements.metadataSidebar || !elements.metadataToggleBtn) return;
    
    const isCollapsed = elements.metadataSidebar.classList.contains('collapsed');
    
    if (isCollapsed) {
        // Expand
        elements.metadataSidebar.classList.remove('collapsed');
        elements.metadataToggleBtn.querySelector('.metadata-toggle-icon').textContent = '‚ñº';
        document.body.classList.add('sidebar-visible');
    } else {
        // Collapse
        elements.metadataSidebar.classList.add('collapsed');
        elements.metadataToggleBtn.querySelector('.metadata-toggle-icon').textContent = '‚ñ∂';
        document.body.classList.remove('sidebar-visible');
    }
}

async function judgeReferenceResponse() {
    if (!state.sessionId) {
        showToast('Please load a notebook first', 'error');
        return;
    }
    
    // Check for missing criteria before judging
    // Compare initial criteria with current criteria from preview
    // Get the JSON version from the converted JSON, not the structured text input
    let currentRefText = '';
    if (state.convertedModelRefJSON) {
        // Use the converted JSON if available
        currentRefText = state.convertedModelRefJSON;
    } else if (elements.jsonPreviewContent && elements.jsonPreviewContent.textContent && 
               !elements.jsonPreviewContent.textContent.includes('Enter criteria') &&
               !elements.jsonPreviewContent.textContent.includes('Error:')) {
        // Use the JSON preview if available
        currentRefText = elements.jsonPreviewContent.textContent.trim();
    } else if (elements.modelrefPreview) {
        // Fallback: get value from input and try to convert
        const inputValue = elements.modelrefPreview.value.trim();
        if (inputValue) {
            // Try to parse as JSON first
            try {
                const parsed = JSON.parse(inputValue);
                if (Array.isArray(parsed)) {
                    currentRefText = inputValue;
                } else {
                    // Not JSON, trigger conversion
                    convertStructuredToJSON();
                    currentRefText = state.convertedModelRefJSON || inputValue;
                }
            } catch (e) {
                // Not JSON, trigger conversion
                convertStructuredToJSON();
                currentRefText = state.convertedModelRefJSON || inputValue;
            }
        }
    }
    
    let currentCriteria;
    try {
        currentCriteria = parseCriteria(currentRefText);
    } catch (error) {
        console.error('Failed to parse criteria:', error);
        console.error('Input text was:', currentRefText.substring(0, 200));
        showToast(`‚ùå Failed to parse criteria: ${error.message}`, 'error');
        return;
    }
    const currentCriteriaIds = new Set(currentCriteria.map(c => c.id));
    const initialCriteriaIds = new Set((state.initialCriteria || []).map(c => c.id));
    const missingBeforeJudge = [...initialCriteriaIds].filter(id => !currentCriteriaIds.has(id));
    
    console.log('üîç PRE-JUDGE CHECK:');
    console.log('   Initial criteria IDs:', Array.from(initialCriteriaIds));
    console.log('   Current criteria IDs:', Array.from(currentCriteriaIds));
    console.log('   Missing criteria IDs:', missingBeforeJudge);
    console.log('   state.initialCriteria exists?', !!state.initialCriteria);
    console.log('   state.initialCriteria length:', state.initialCriteria?.length || 0);
    
    // Check minimum 3 criteria requirement
    if (currentCriteria.length < 3) {
        const resultDiv = elements.referenceJudgeResult;
        resultDiv.innerHTML = `
            <div style="padding: 1rem; background: var(--bg-primary); border-radius: 8px; border: 2px solid var(--warning);">
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <span style="font-size: 1.5rem;">‚ö†Ô∏è</span>
                    <span style="font-weight: 600; color: var(--warning);">Minimum 3 Criteria Required</span>
                </div>
                <p style="margin-bottom: 0.5rem; color: var(--text-secondary);">
                    You currently have <strong>${currentCriteria.length} criteria</strong> in your response_reference.
                </p>
                <p style="color: var(--text-secondary); font-size: 0.9rem;">
                    <strong>Requirement:</strong> You must have at least <strong>3 criteria</strong> before judging.<br>
                    Please add more criteria to your response_reference section in your Colab notebook.
                </p>
            </div>
        `;
        resultDiv.classList.remove('hidden');
        // Keep response editor in view
        const responseEditor = document.getElementById('responseEditor');
        if (responseEditor) {
            responseEditor.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
        }
        showToast(`‚ùå Minimum 3 criteria required. Currently have ${currentCriteria.length}.`, 'error');
        return;
    }
    
    if (missingBeforeJudge.length > 0) {
        const missingIds = missingBeforeJudge.join(', ');
        showToast(`‚ùå Cannot judge: Missing criteria ${missingIds}. Please add them back to response_reference and try again.`, 'error');
        // Show a warning in the result div
        const resultDiv = elements.referenceJudgeResult;
        resultDiv.innerHTML = `
            <div style="padding: 1rem; background: var(--bg-primary); border-radius: 8px; border: 2px solid var(--warning);">
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <span style="font-size: 1.5rem;">‚ö†Ô∏è</span>
                    <span style="font-weight: 600; color: var(--warning);">Missing Criteria Detected</span>
                </div>
                <p style="margin-bottom: 0.5rem; color: var(--text-secondary);">
                    The following criteria were in the original notebook but are missing from the current response_reference:
                </p>
                <ul style="margin-left: 1.5rem; margin-bottom: 0.75rem; color: var(--warning);">
                    ${missingBeforeJudge.map(id => {
                        const criterion = (state.initialCriteria || []).find(c => c.id === id);
                        return `<li><strong>${id}</strong>: ${criterion ? escapeHtml(criterion.criteria) : 'Criterion description not found'}</li>`;
                    }).join('')}
                </ul>
                <p style="color: var(--text-secondary); font-size: 0.9rem;">
                    <strong>Action Required:</strong> Please add these criteria back to the response_reference section in your Colab notebook, then click "Judge Reference" again.
                </p>
            </div>
        `;
        resultDiv.classList.remove('hidden');
        // Keep response editor in view
        const responseEditor = document.getElementById('responseEditor');
        if (responseEditor) {
            responseEditor.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
        }
        return;
    }
    
    // Use the button that was clicked (could be judgeReferenceBtn or judgeBeforeHuntBtn)
    const btn = event?.target?.id === 'judgeBeforeHuntBtn' ? elements.judgeBeforeHuntBtn : elements.judgeReferenceBtn;
    const resultDiv = elements.referenceJudgeResult;
    
    try {
        if (btn) {
            btn.disabled = true;
            btn.textContent = '‚è≥ Judging...';
        }
        // Don't hide the result div - just clear it, so response editor stays visible
        if (resultDiv) {
            resultDiv.innerHTML = '';
            resultDiv.classList.add('hidden');
        }
        
        const response = await fetch(`/api/judge-reference/${state.sessionId}`, {
            method: 'POST'
        });
        
        if (!response.ok) {
            if (response.status === 404) {
                // Session not found - likely expired or invalid
                showToast('‚ö†Ô∏è Session expired. Please reload the notebook.', 'error');
                throw new Error('Session not found. Please reload the notebook from Colab.');
            }
            const error = await response.json();
            throw new Error(error.detail || 'Judge failed');
        }
        
        const data = await response.json();
        
        // Update state.criteria from judge result to keep in sync
        let criteria = data.criteria || {};
        let criteriaEntries = Object.entries(criteria); // Use let, not const
        
        // Debug: Log what criteria were judged
        console.log('Judge result criteria:', Object.keys(criteria));
        console.log('Initial criteria IDs:', (state.initialCriteria || []).map(c => c.id));
        console.log('Current state.criteria IDs (before update):', (state.criteria || []).map(c => c.id));
        
        // IMPORTANT: Re-parse criteria from fresh response_reference if provided
        // This ensures state.criteria matches what was actually in the notebook when judging
        let currentCriteria = [];
        if (data.response_reference) {
            console.log('Re-parsing criteria from fresh response_reference');
            try {
            currentCriteria = parseCriteria(data.response_reference);
            state.criteria = currentCriteria;
            console.log('Updated state.criteria IDs (from response_reference):', state.criteria.map(c => c.id));
            } catch (error) {
                console.error('Failed to parse criteria:', error);
                showToast(`‚ùå Failed to parse criteria: ${error.message}`, 'error');
                return;
            }
        } else {
            // Fallback: Update state.criteria based on what was actually judged
            const judgedCriteriaIds = new Set(Object.keys(criteria));
            state.criteria = (state.criteria || []).filter(c => judgedCriteriaIds.has(c.id));
            currentCriteria = state.criteria;
        }
        
        // CRITICAL: Filter out criteria from judge result that are NOT in response_reference
        // These should be marked as MISSING, not FAIL
        const currentCriteriaIds = new Set(currentCriteria.map(c => c.id));
        const judgedCriteriaIds = new Set(Object.keys(criteria));
        const criteriaNotInResponseRef = [...judgedCriteriaIds].filter(id => !currentCriteriaIds.has(id));
        
        if (criteriaNotInResponseRef.length > 0) {
            console.warn('‚ö†Ô∏è Judge returned criteria not in response_reference:', criteriaNotInResponseRef);
            console.warn('   These will be marked as MISSING instead of their judge status (FAIL/PASS)');
            // Mark these as MISSING and add them to state.criteria
            for (const id of criteriaNotInResponseRef) {
                criteria[id] = 'MISSING';
                // Add to state.criteria if not already there
                if (!state.criteria.find(c => c.id === id)) {
                    state.criteria.push({ 
                        id: id, 
                        criteria: `Criterion ${id} (not in response_reference - please add it back)` 
                    });
                    console.log(`‚úÖ Added missing criterion ${id} to state.criteria (from judge result)`);
                }
            }
            // Recalculate entries after adding MISSING
            criteriaEntries = Object.entries(criteria);
        }
        
        // Check for missing criteria: Compare initial criteria with what was actually judged
        // With independent judging, ALL criteria in response_reference should be evaluated
        // If a criterion was in initial but not in judge result, it's MISSING
        const initialCriteriaIds = new Set((state.initialCriteria || []).map(c => c.id));
        // Use judgedCriteriaIds (what judge actually returned) instead of currentCriteriaIds
        // This ensures we detect if judge didn't evaluate a criterion that should be there
        const missingCriteriaIds = [...initialCriteriaIds].filter(id => !judgedCriteriaIds.has(id));
        
        console.log('üîç POST-JUDGE MISSING CHECK:');
        console.log('   Initial criteria IDs:', Array.from(initialCriteriaIds));
        console.log('   Current criteria IDs (from response_reference):', Array.from(currentCriteriaIds));
        console.log('   Judged criteria IDs (from judge result):', Array.from(judgedCriteriaIds));
        console.log('   Missing criteria IDs (in initial but not in judge result):', missingCriteriaIds);
        console.log('   state.initialCriteria exists?', !!state.initialCriteria);
        console.log('   state.initialCriteria length:', state.initialCriteria?.length || 0);
        console.log('   state.initialCriteria:', state.initialCriteria);
        
        // Also check if criteria are in response_reference but not judged (shouldn't happen with independent judging)
        const inResponseRefButNotJudged = [...currentCriteriaIds].filter(id => !judgedCriteriaIds.has(id));
        if (inResponseRefButNotJudged.length > 0) {
            console.warn('‚ö†Ô∏è WARNING: Criteria in response_reference but not in judge result:', inResponseRefButNotJudged);
            console.warn('   This should not happen with independent judging - all criteria in response_reference should be evaluated');
        }
        
        if (missingCriteriaIds.length > 0) {
            console.warn('‚ö†Ô∏è MISSING CRITERIA DETECTED:', missingCriteriaIds);
            // Add missing criteria to judge result as MISSING
            for (const missingId of missingCriteriaIds) {
                // Don't overwrite if already in criteria (shouldn't happen, but just in case)
                if (!(missingId in criteria)) {
                    criteria[missingId] = 'MISSING';
                }
                // Also add to state.criteria so it shows in UI
                const missingCriterion = (state.initialCriteria || []).find(c => c.id === missingId);
                if (missingCriterion) {
                    if (!state.criteria.find(c => c.id === missingId)) {
                        state.criteria.push(missingCriterion);
                        console.log(`‚úÖ Added missing criterion ${missingId} to state.criteria`);
                    } else {
                        console.log(`‚ÑπÔ∏è Missing criterion ${missingId} already in state.criteria`);
                    }
                } else {
                    console.error(`‚ùå ERROR: Missing criterion ${missingId} not found in state.initialCriteria!`);
                    console.error('   This means the notebook was loaded AFTER this criterion was removed from response_reference.');
                    console.error('   state.initialCriteria:', state.initialCriteria);
                    console.error('   To fix: Reload the notebook from the ORIGINAL Colab URL (before C4 was removed)');
                    // Still add it to state.criteria as MISSING even without description
                    // This ensures it shows in the UI
                    if (!state.criteria.find(c => c.id === missingId)) {
                        state.criteria.push({ id: missingId, criteria: `Criterion ${missingId} (description not available - was removed before notebook was loaded)` });
                        console.log(`‚ö†Ô∏è Added missing criterion ${missingId} to state.criteria without description`);
                    }
                }
            }
            // Recalculate entries after adding MISSING
            criteriaEntries = Object.entries(criteria);
        } else {
            console.log('‚úÖ No missing criteria detected - all initial criteria were evaluated by judge');
            
            // Optional: Check for sequential gaps as a WARNING only (not marking as missing)
            // This helps identify potential issues but doesn't assume criteria should exist
            const allCriteriaIds = new Set([...initialCriteriaIds, ...currentCriteriaIds, ...judgedCriteriaIds]);
            const criteriaNumbers = Array.from(allCriteriaIds)
                .map(id => {
                    const match = id.match(/^C(\d+)$/i);
                    return match ? parseInt(match[1]) : null;
                })
                .filter(num => num !== null)
                .sort((a, b) => a - b);
            
            if (criteriaNumbers.length > 0) {
                const minNum = Math.min(...criteriaNumbers);
                const maxNum = Math.max(...criteriaNumbers);
                
                // Check for sequential gaps (e.g., C1, C2, C17 - missing C3-C16)
                const sequentialGaps = [];
                for (let i = minNum; i <= maxNum; i++) {
                    const cId = `C${i}`;
                    if (!allCriteriaIds.has(cId)) {
                        sequentialGaps.push(cId);
                    }
                }
                
                if (sequentialGaps.length > 0) {
                    console.warn('‚ö†Ô∏è SEQUENTIAL GAP DETECTED (WARNING ONLY - not marking as missing):', sequentialGaps);
                    console.warn('   This suggests non-sequential criteria IDs. This is OK if those criteria never existed.');
                    console.warn('   Only criteria in initialCriteria will be marked as MISSING.');
                }
            }
            
            // Double-check: if judge result has fewer criteria than initial, something might be wrong
            if (initialCriteriaIds.size > judgedCriteriaIds.size) {
                const notJudged = [...initialCriteriaIds].filter(id => !judgedCriteriaIds.has(id));
                console.warn('‚ö†Ô∏è WARNING: Some initial criteria were not judged:', notJudged);
                console.warn('   This might indicate criteria were removed from response_reference after initial load');
            }
        }
        
        console.log('Final state.criteria IDs:', state.criteria.map(c => c.id));
        console.log('Final judge result criteria (including missing):', Object.keys(criteria));
        console.log('Final criteria object:', criteria);
        
        // Check if ALL criteria pass (not just overall score)
        // Missing criteria (MISSING status) don't count as failures, but block hunting
        const evaluatedCriteria = criteriaEntries.filter(([key, value]) => 
            String(value).toUpperCase() !== 'MISSING'
        );
        const missingCriteria = criteriaEntries.filter(([key, value]) => 
            String(value).toUpperCase() === 'MISSING'
        );
        const allCriteriaPass = evaluatedCriteria.length > 0 && 
            evaluatedCriteria.every(([key, value]) => String(value).toUpperCase() === 'PASS');
        
        // Block hunting if there are missing criteria
        const hasMissingCriteria = missingCriteria.length > 0;
        const isPassing = allCriteriaPass && !hasMissingCriteria;
        const scoreClass = isPassing ? 'score-1' : 'score-0';
        const scoreEmoji = isPassing ? '‚úÖ' : '‚ùå';
        
        // Update reference validated state
        state.referenceValidated = isPassing;
        
        // Enable/disable Start Hunt based on result
        // Requirements: JSON valid + All criteria present + All criteria pass + No missing criteria
        if (elements.startHuntBtn) {
            // First check: JSON must be valid
            if (!state.modelRefValid) {
                elements.startHuntBtn.disabled = true;
                elements.startHuntBtn.title = 'Model Reference must be valid JSON before hunting';
            }
            // Second check: All criteria must be present (no missing)
            else if (hasMissingCriteria) {
                const missingIds = missingCriteria.map(([id]) => id).join(', ');
                elements.startHuntBtn.disabled = true;
                elements.startHuntBtn.title = `Missing criteria: ${missingIds}. Please add them back to response_reference and re-judge.`;
            }
            // Third check: All criteria must pass
            else if (isPassing && !hasMissingCriteria) {
                elements.startHuntBtn.disabled = false;
                elements.startHuntBtn.title = '';
            } else {
                elements.startHuntBtn.disabled = true;
                elements.startHuntBtn.title = 'All criteria must pass before starting hunt';
            }
        }
        
        // Build criteria breakdown HTML
        const criteriaHtml = formatJudgeCriteriaDisplay(criteria);
        
        // Build status message
        let statusMessage = '';
        if (hasMissingCriteria) {
            const missingIds = missingCriteria.map(([id]) => id).join(', ');
            statusMessage = `‚ö†Ô∏è MISSING CRITERIA: ${missingIds} - Please add them back to response_reference and re-judge`;
        } else if (isPassing) {
            statusMessage = 'ALL CRITERIA PASS - Hunt Enabled!';
        } else {
            statusMessage = 'CRITERIA FAILED - Fix before hunting';
        }
        
        resultDiv.innerHTML = `
            <div style="padding: 1rem; background: var(--bg-primary); border-radius: 8px; border: 1px solid ${hasMissingCriteria ? 'var(--warning)' : (isPassing ? 'var(--success)' : 'var(--danger)')};">
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <span class="score-badge ${scoreClass}">${scoreEmoji} Score: ${data.score}</span>
                    <span style="font-weight: 600;">${statusMessage}</span>
                </div>
                
                <!-- Criteria Breakdown -->
                <div style="margin-top: 0.75rem;">
                    <label style="font-weight: 600; font-size: 0.9rem;">üìã Criteria Breakdown:</label>
                    ${criteriaHtml}
                </div>
                
                <div style="margin-top: 0.75rem;">
                    <label style="font-weight: 600; font-size: 0.9rem;">üìù Judge Explanation:</label>
                    <p style="margin-top: 0.25rem; font-size: 0.9rem; color: var(--text-secondary); white-space: pre-wrap;">${escapeHtml(data.explanation || 'No explanation provided')}</p>
                    ${missingCriteria && missingCriteria.length > 0 ? `
                    <div style="margin-top: 0.5rem; padding: 0.5rem; background: var(--warning-bg); border-left: 3px solid var(--warning); border-radius: 4px; font-size: 0.85rem;">
                        <strong>‚ö†Ô∏è Note:</strong> The judge's explanation above refers only to the criteria present in <code>response_reference</code> (${evaluatedCriteria.length} criteria evaluated). 
                        ${missingCriteria.length} criterion/criteria (${missingCriteria.map(([id]) => id).join(', ')}) ${missingCriteria.length === 1 ? 'is' : 'are'} missing from <code>response_reference</code> and ${missingCriteria.length === 1 ? 'was' : 'were'} not evaluated.
                    </div>
                    ` : ''}
                </div>
                
                ${(data.score === null || !criteria || Object.keys(criteria).length === 0) ? `
                <div style="margin-top: 0.75rem; padding: 0.5rem; background: var(--danger-bg); border-radius: 4px;">
                    <label style="font-weight: 600; font-size: 0.9rem; color: var(--danger);">‚ö†Ô∏è Debug - Raw Output:</label>
                    <pre style="margin-top: 0.25rem; font-size: 0.8rem; color: var(--text-secondary); white-space: pre-wrap; max-height: 200px; overflow: auto;">${escapeHtml(data.raw_output || 'No raw output')}</pre>
                </div>
                ` : ''}
            </div>
        `;
        // Show result div below response editor (not covering it)
        resultDiv.classList.remove('hidden');
        // Scroll response editor into view first, then show result
        const responseEditor = document.getElementById('responseEditor');
        if (responseEditor) {
            // Keep response editor in view - don't scroll away
            responseEditor.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
        }
        
        const passCount = criteriaEntries.filter(([k, v]) => String(v).toUpperCase() === 'PASS').length;
        const totalCount = criteriaEntries.length;
        showToast(`Reference: ${passCount}/${totalCount} criteria pass (${isPassing ? 'HUNT ENABLED' : 'Fix required'})`, isPassing ? 'success' : 'warning');
        
    } catch (error) {
        // Display error prominently in result div
        resultDiv.innerHTML = `
            <div style="padding: 1rem; background: var(--danger-bg); border-radius: 8px; border: 2px solid var(--danger);">
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <span style="font-size: 1.2rem;">‚ùå</span>
                    <span style="font-weight: 600; color: var(--danger); font-size: 1rem;">Judge Error</span>
                </div>
                <div style="margin-top: 0.75rem;">
                    <label style="font-weight: 600; font-size: 0.9rem; color: var(--danger);">Error Message:</label>
                    <p style="margin-top: 0.25rem; font-size: 0.9rem; color: var(--text-primary); white-space: pre-wrap; word-break: break-word;">${escapeHtml(error.message || 'Unknown error occurred')}</p>
                </div>
            </div>
        `;
        resultDiv.classList.remove('hidden');
        // Keep response editor in view
        const responseEditor = document.getElementById('responseEditor');
        if (responseEditor) {
            responseEditor.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
        }
        
        // Also show toast
        showToast(`Error: ${error.message}`, 'error');
        
        // Disable hunt button on error
        if (elements.startHuntBtn) {
            elements.startHuntBtn.disabled = true;
            elements.startHuntBtn.title = 'Fix judge error before starting hunt';
        }
        state.referenceValidated = false;
    } finally {
        if (btn) {
            btn.disabled = false;
            // Update button text based on which button it is
            if (btn.id === 'judgeBeforeHuntBtn') {
                btn.textContent = '‚öñÔ∏è Judge Reference';
            } else if (btn.id === 'judgeReferenceBtn') {
                btn.textContent = '‚öñÔ∏è Judge Only';
            }
        }
    }
}

// Save Response Only (without judging)
async function saveResponseOnly() {
    if (!state.sessionId) {
        showToast('Please load a notebook first', 'error');
        return;
    }
    
    const btn = elements.saveResponseBtn;
    if (!btn) {
        showToast('Save button not found', 'error');
        return;
    }
    
    // Get response from rich text editor (contenteditable div)
    const responseEditor = elements.referencePreview;
    const newResponse = responseEditor?.textContent || responseEditor?.innerText || '';
    
    if (!newResponse.trim()) {
        showToast('Response cannot be empty', 'error');
        return;
    }
    
    try {
        btn.disabled = true;
        btn.textContent = 'üíæ Saving...';
        
        // Save to Colab
        const saveResponse = await fetch(`/api/update-response/${state.sessionId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ response: newResponse })
        });
        
        if (!saveResponse.ok) {
            const error = await saveResponse.json();
            throw new Error(error.detail || 'Failed to save to Colab');
        }
        
        // CRITICAL: Update originalNotebookJson so snapshot saves include this cell
        updateOriginalNotebookWithCell('response', newResponse);
        
        showToast('‚úÖ Saved to Colab!', 'success');
        
    } catch (error) {
        showToast(`Error: ${error.message}`, 'error');
    } finally {
        btn.disabled = false;
        btn.textContent = 'üíæ Save Response';
    }
}

// Combined Save & Judge function for Response tab (legacy - not used anymore)
async function saveAndJudgeResponse() {
    if (!state.sessionId) {
        showToast('Please load a notebook first', 'error');
        return;
    }
    
    // Check minimum 3 criteria requirement
    const currentRefText = elements.modelrefPreview?.textContent || '';
    let currentCriteria;
    try {
        currentCriteria = parseCriteria(currentRefText);
    } catch (error) {
        console.error('Failed to parse criteria:', error);
        showToast(`‚ùå Failed to parse criteria: ${error.message}`, 'error');
        return;
    }
    if (currentCriteria.length < 3) {
        showToast(`‚ùå Minimum 3 criteria required. Currently have ${currentCriteria.length}. Please add more criteria before saving.`, 'error');
        return;
    }
    
    const btn = elements.saveAndJudgeResponseBtn;
    if (!btn) {
        showToast('Save & Judge button not found', 'error');
        return;
    }
    const resultDiv = elements.referenceJudgeResult;
    // Get response from rich text editor (contenteditable div)
    const responseEditor = elements.referencePreview;
    const newResponse = responseEditor?.textContent || responseEditor?.innerText || '';
    
    if (!newResponse.trim()) {
        showToast('Response cannot be empty', 'error');
        return;
    }
    
    try {
        btn.disabled = true;
        btn.textContent = 'üíæ Saving...';
        // Don't hide result div - keep response editor visible
        if (resultDiv) {
            resultDiv.innerHTML = '';
            resultDiv.classList.add('hidden');
        }
        
        // Step 1: Save to Colab
        const saveResponse = await fetch(`/api/update-response/${state.sessionId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ response: newResponse })
        });
        
        if (!saveResponse.ok) {
            const error = await saveResponse.json();
            throw new Error(error.detail || 'Failed to save to Colab');
        }
        
        // CRITICAL: Update originalNotebookJson so snapshot saves include this cell
        updateOriginalNotebookWithCell('response', newResponse);
        
        showToast('‚úÖ Saved to Colab!', 'success');
        btn.textContent = '‚öñÔ∏è Judging...';
        
        // Step 2: Judge
        const judgeResponse = await fetch(`/api/judge-reference/${state.sessionId}`, {
            method: 'POST'
        });
        
        if (!judgeResponse.ok) {
            if (judgeResponse.status === 404) {
                showToast('‚ö†Ô∏è Session expired. Please reload the notebook.', 'error');
                throw new Error('Session not found. Please reload the notebook from Colab.');
            }
            const error = await judgeResponse.json();
            throw new Error(error.detail || 'Judge failed');
        }
        
        const data = await judgeResponse.json();
        
        // Update state.criteria from judge result
        let criteria = data.criteria || {};
        let criteriaEntries = Object.entries(criteria);
        
        // Check for missing criteria
        const evaluatedCriteria = criteriaEntries.map(([id]) => id);
        const missingCriteria = (state.initialCriteria || [])
            .filter(c => !evaluatedCriteria.includes(c.id))
            .map(c => [c.id, c.criteria]);
        const hasMissingCriteria = missingCriteria.length > 0;
        
        // Determine if all criteria pass
        const allCriteriaPass = criteriaEntries.length > 0 && 
            criteriaEntries.every(([k, v]) => String(v).toUpperCase() === 'PASS');
        const isPassing = allCriteriaPass && !hasMissingCriteria;
        
        const scoreClass = isPassing ? 'score-1' : 'score-0';
        const scoreEmoji = isPassing ? '‚úÖ' : '‚ùå';
        
        // Update reference validated state
        state.referenceValidated = isPassing;
        
        // Enable/disable Start Hunt based on result
        if (elements.startHuntBtn) {
            if (!state.modelRefValid) {
                elements.startHuntBtn.disabled = true;
                elements.startHuntBtn.title = 'Model Reference must be valid JSON before hunting';
            } else if (hasMissingCriteria) {
                const missingIds = missingCriteria.map(([id]) => id).join(', ');
                elements.startHuntBtn.disabled = true;
                elements.startHuntBtn.title = `Missing criteria: ${missingIds}. Please add them back to response_reference and re-judge.`;
            } else if (isPassing && !hasMissingCriteria) {
                elements.startHuntBtn.disabled = false;
                elements.startHuntBtn.title = '';
            } else {
                elements.startHuntBtn.disabled = true;
                elements.startHuntBtn.title = 'All criteria must pass before starting hunt';
            }
        }
        
        // Build criteria breakdown HTML
        const criteriaHtml = formatJudgeCriteriaDisplay(criteria);
        
        // Build status message
        let statusMessage = '';
        if (hasMissingCriteria) {
            const missingIds = missingCriteria.map(([id]) => id).join(', ');
            statusMessage = `‚ö†Ô∏è Saved but MISSING CRITERIA: ${missingIds} - Please add them back to response_reference and re-judge`;
        } else if (isPassing) {
            statusMessage = '‚úÖ Saved & ALL CRITERIA PASS - Hunt Enabled!';
        } else {
            statusMessage = '‚ùå Saved but CRITERIA FAILED - Edit & try again';
        }
        
        resultDiv.innerHTML = `
            <div style="padding: 1rem; background: var(--bg-primary); border-radius: 8px; border: 1px solid ${hasMissingCriteria ? 'var(--warning)' : (isPassing ? 'var(--success)' : 'var(--danger)')};">
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <span class="score-badge ${scoreClass}">${scoreEmoji} Score: ${data.score}</span>
                    <span style="font-weight: 600;">${statusMessage}</span>
                </div>
                
                <!-- Criteria Breakdown -->
                <div style="margin-top: 0.75rem;">
                    <label style="font-weight: 600; font-size: 0.9rem;">üìã Criteria Breakdown:</label>
                    ${criteriaHtml}
                </div>
                
                <div style="margin-top: 0.75rem;">
                    <label style="font-weight: 600; font-size: 0.9rem;">üìù Judge Explanation:</label>
                    <p style="margin-top: 0.25rem; font-size: 0.9rem; color: var(--text-secondary); white-space: pre-wrap;">${escapeHtml(data.explanation || 'No explanation provided')}</p>
                    ${missingCriteria && missingCriteria.length > 0 ? `
                    <div style="margin-top: 0.5rem; padding: 0.5rem; background: var(--warning-bg); border-left: 3px solid var(--warning); border-radius: 4px; font-size: 0.85rem;">
                        <strong>‚ö†Ô∏è Note:</strong> The judge's explanation above refers only to the criteria present in <code>response_reference</code> (${evaluatedCriteria.length} criteria evaluated). 
                        ${missingCriteria.length} criterion/criteria (${missingCriteria.map(([id]) => id).join(', ')}) ${missingCriteria.length === 1 ? 'is' : 'are'} missing from <code>response_reference</code> and ${missingCriteria.length === 1 ? 'was' : 'were'} not evaluated.
                    </div>
                    ` : ''}
                </div>
            </div>
        `;
        // Show result div below response editor (expands downward)
        resultDiv.classList.remove('hidden');
        // Keep response editor in view - don't scroll away
        const responseEditor = document.getElementById('responseEditor');
        if (responseEditor) {
            // Just ensure editor is visible, don't scroll to result
            responseEditor.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
        }
        
        const passCount = criteriaEntries.filter(([k, v]) => String(v).toUpperCase() === 'PASS').length;
        const totalCount = criteriaEntries.length;
        showToast(`Saved & Judged: ${passCount}/${totalCount} criteria pass (${isPassing ? 'HUNT ENABLED' : 'Fix required'})`, isPassing ? 'success' : 'warning');
        
    } catch (error) {
        showToast(`Error: ${error.message}`, 'error');
        // Display error in result div
        if (resultDiv) {
            resultDiv.innerHTML = `
                <div style="padding: 1rem; background: var(--danger-bg); border-radius: 8px; border: 2px solid var(--danger);">
                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                        <span style="font-size: 1.2rem;">‚ùå</span>
                        <span style="font-weight: 600; color: var(--danger); font-size: 1rem;">Error</span>
                    </div>
                    <div style="margin-top: 0.75rem;">
                        <label style="font-weight: 600; font-size: 0.9rem; color: var(--danger);">Error Message:</label>
                        <p style="margin-top: 0.25rem; font-size: 0.9rem; color: var(--text-primary); white-space: pre-wrap; word-break: break-word;">${escapeHtml(error.message || 'Unknown error occurred')}</p>
                    </div>
                </div>
            `;
            resultDiv.classList.remove('hidden');
            // Keep response editor in view
            const responseEditor = document.getElementById('responseEditor');
            if (responseEditor) {
                responseEditor.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
            }
        }
        
        // Disable hunt button on error
        if (elements.startHuntBtn) {
            elements.startHuntBtn.disabled = true;
            elements.startHuntBtn.title = 'Fix error before starting hunt';
        }
        state.referenceValidated = false;
    } finally {
        btn.disabled = false;
        btn.textContent = 'üíæ‚öñÔ∏è Save & Judge Response';
    }
}

// Save edited response to Colab and re-judge (legacy function)
async function saveAndRejudge() {
    if (!state.sessionId) {
        showToast('Please load a notebook first', 'error');
        return;
    }
    
    // Check minimum 3 criteria requirement
    const currentRefText = elements.modelrefPreview?.textContent || '';
    let currentCriteria;
    try {
        currentCriteria = parseCriteria(currentRefText);
    } catch (error) {
        console.error('Failed to parse criteria:', error);
        showToast(`‚ùå Failed to parse criteria: ${error.message}`, 'error');
        return;
    }
    if (currentCriteria.length < 3) {
        showToast(`‚ùå Minimum 3 criteria required. Currently have ${currentCriteria.length}. Please add more criteria before saving.`, 'error');
        return;
    }
    
    const btn = elements.saveResponseBtn;
    const resultDiv = elements.referenceJudgeResult;
    const newResponse = elements.referencePreview.value;
    
    if (!newResponse.trim()) {
        showToast('Response cannot be empty', 'error');
        return;
    }
    
    try {
        btn.disabled = true;
        btn.textContent = 'üíæ Saving...';
        resultDiv.classList.add('hidden');
        
        // Step 1: Save to Colab
        const saveResponse = await fetch(`/api/update-response/${state.sessionId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ response: newResponse })
        });
        
        if (!saveResponse.ok) {
            const error = await saveResponse.json();
            throw new Error(error.detail || 'Failed to save to Colab');
        }
        
        // CRITICAL: Update originalNotebookJson so snapshot saves include this cell
        updateOriginalNotebookWithCell('response', newResponse);
        
        showToast('‚úÖ Saved to Colab!', 'success');
        btn.textContent = '‚öñÔ∏è Re-judging...';
        
        // Step 2: Re-judge
        const judgeResponse = await fetch(`/api/judge-reference/${state.sessionId}`, {
            method: 'POST'
        });
        
        if (!judgeResponse.ok) {
            if (judgeResponse.status === 404) {
                // Session not found - likely expired or invalid
                showToast('‚ö†Ô∏è Session expired. Please reload the notebook.', 'error');
                throw new Error('Session not found. Please reload the notebook from Colab.');
            }
            const error = await judgeResponse.json();
            throw new Error(error.detail || 'Judge failed');
        }
        
        const data = await judgeResponse.json();
        
        // Update state.criteria from judge result to keep in sync
        let criteria = data.criteria || {};
        let criteriaEntries = Object.entries(criteria);
        
        // Debug: Log what criteria were judged
        console.log('Judge result criteria (saveAndRejudge):', Object.keys(criteria));
        console.log('Initial criteria IDs:', (state.initialCriteria || []).map(c => c.id));
        console.log('Current state.criteria IDs (before update):', (state.criteria || []).map(c => c.id));
        
        // IMPORTANT: Re-parse criteria from fresh response_reference if provided
        // This ensures state.criteria matches what was actually in the notebook when judging
        let currentCriteria = [];
        if (data.response_reference) {
            console.log('Re-parsing criteria from fresh response_reference (saveAndRejudge)');
            try {
            currentCriteria = parseCriteria(data.response_reference);
            state.criteria = currentCriteria;
            console.log('Updated state.criteria IDs (from response_reference):', state.criteria.map(c => c.id));
            } catch (error) {
                console.error('Failed to parse criteria:', error);
                showToast(`‚ùå Failed to parse criteria: ${error.message}`, 'error');
                return;
            }
        } else {
            // Fallback: Update state.criteria based on what was actually judged
            const judgedCriteriaIds = new Set(Object.keys(criteria));
            state.criteria = (state.criteria || []).filter(c => judgedCriteriaIds.has(c.id));
            currentCriteria = state.criteria;
        }
        
        // CRITICAL: Filter out criteria from judge result that are NOT in response_reference
        // These should be marked as MISSING, not FAIL
        const currentCriteriaIds = new Set(currentCriteria.map(c => c.id));
        const judgedCriteriaIds = new Set(Object.keys(criteria));
        const criteriaNotInResponseRef = [...judgedCriteriaIds].filter(id => !currentCriteriaIds.has(id));
        
        if (criteriaNotInResponseRef.length > 0) {
            console.warn('‚ö†Ô∏è Judge returned criteria not in response_reference (saveAndRejudge):', criteriaNotInResponseRef);
            console.warn('   These will be marked as MISSING instead of their judge status (FAIL/PASS)');
            // Mark these as MISSING and add them to state.criteria
            for (const id of criteriaNotInResponseRef) {
                criteria[id] = 'MISSING';
                // Add to state.criteria if not already there
                if (!state.criteria.find(c => c.id === id)) {
                    state.criteria.push({ 
                        id: id, 
                        criteria: `Criterion ${id} (not in response_reference - please add it back)` 
                    });
                    console.log(`‚úÖ Added missing criterion ${id} to state.criteria (from judge result, saveAndRejudge)`);
                }
            }
            // Recalculate entries after adding MISSING
            criteriaEntries = Object.entries(criteria);
        }
        
        // Check for missing criteria: Compare initial criteria with what was actually judged
        // With independent judging, ALL criteria in response_reference should be evaluated
        const initialCriteriaIds = new Set((state.initialCriteria || []).map(c => c.id));
        const judgedCriteriaIdsSet = new Set(Object.keys(criteria));
        const missingCriteriaIds = [...initialCriteriaIds].filter(id => !judgedCriteriaIdsSet.has(id));
        
        console.log('DEBUG: Missing criteria check (saveAndRejudge) - Initial:', Array.from(initialCriteriaIds), 'Current:', Array.from(currentCriteriaIds), 'Judged:', Array.from(judgedCriteriaIdsSet), 'Missing:', missingCriteriaIds);
        
        if (missingCriteriaIds.length > 0) {
            console.warn('Missing criteria detected (saveAndRejudge):', missingCriteriaIds);
            // Add missing criteria to judge result as MISSING
            for (const missingId of missingCriteriaIds) {
                criteria[missingId] = 'MISSING';
                // Also add to state.criteria so it shows in UI
                const missingCriterion = (state.initialCriteria || []).find(c => c.id === missingId);
                if (missingCriterion && !state.criteria.find(c => c.id === missingId)) {
                    state.criteria.push(missingCriterion);
                }
            }
            // Recalculate entries after adding MISSING
            criteriaEntries = Object.entries(criteria);
        } else {
            console.log('‚úÖ No missing criteria detected (saveAndRejudge) - all initial criteria are present in current response_reference');
            
            // Optional: Check for sequential gaps as a WARNING only (not marking as missing)
            // This helps identify potential issues but doesn't assume criteria should exist
            const allCriteriaIds = new Set([...initialCriteriaIds, ...currentCriteriaIds, ...judgedCriteriaIds]);
            const criteriaNumbers = Array.from(allCriteriaIds)
                .map(id => {
                    const match = id.match(/^C(\d+)$/i);
                    return match ? parseInt(match[1]) : null;
                })
                .filter(num => num !== null)
                .sort((a, b) => a - b);
            
            if (criteriaNumbers.length > 0) {
                const minNum = Math.min(...criteriaNumbers);
                const maxNum = Math.max(...criteriaNumbers);
                
                // Check for sequential gaps (e.g., C1, C2, C17 - missing C3-C16)
                const sequentialGaps = [];
                for (let i = minNum; i <= maxNum; i++) {
                    const cId = `C${i}`;
                    if (!allCriteriaIds.has(cId)) {
                        sequentialGaps.push(cId);
                    }
                }
                
                if (sequentialGaps.length > 0) {
                    console.warn('‚ö†Ô∏è SEQUENTIAL GAP DETECTED (WARNING ONLY - not marking as missing, saveAndRejudge):', sequentialGaps);
                    console.warn('   This suggests non-sequential criteria IDs. This is OK if those criteria never existed.');
                    console.warn('   Only criteria in initialCriteria will be marked as MISSING.');
                }
            }
        }
        
        console.log('Final state.criteria IDs (saveAndRejudge):', state.criteria.map(c => c.id));
        console.log('Final judge result criteria (including missing):', Object.keys(criteria));
        
        // Check if ALL criteria pass (not just overall score)
        // Missing criteria (MISSING status) don't count as failures, but block hunting
        const evaluatedCriteria = criteriaEntries.filter(([key, value]) => 
            String(value).toUpperCase() !== 'MISSING'
        );
        const missingCriteria = criteriaEntries.filter(([key, value]) => 
            String(value).toUpperCase() === 'MISSING'
        );
        const allCriteriaPass = evaluatedCriteria.length > 0 && 
            evaluatedCriteria.every(([key, value]) => String(value).toUpperCase() === 'PASS');
        
        // Block hunting if there are missing criteria
        const hasMissingCriteria = missingCriteria.length > 0;
        const isPassing = allCriteriaPass && !hasMissingCriteria;
        const scoreClass = isPassing ? 'score-1' : 'score-0';
        const scoreEmoji = isPassing ? '‚úÖ' : '‚ùå';
        
        // Update reference validated state
        state.referenceValidated = isPassing;
        
        // Enable/disable Start Hunt based on result
        // Requirements: JSON valid + All criteria present + All criteria pass + No missing criteria
        if (elements.startHuntBtn) {
            // First check: JSON must be valid
            if (!state.modelRefValid) {
                elements.startHuntBtn.disabled = true;
                elements.startHuntBtn.title = 'Model Reference must be valid JSON before hunting';
            }
            // Second check: All criteria must be present (no missing)
            else if (hasMissingCriteria) {
                const missingIds = missingCriteria.map(([id]) => id).join(', ');
                elements.startHuntBtn.disabled = true;
                elements.startHuntBtn.title = `Missing criteria: ${missingIds}. Please add them back to response_reference and re-judge.`;
            }
            // Third check: All criteria must pass
            else if (isPassing && !hasMissingCriteria) {
                elements.startHuntBtn.disabled = false;
                elements.startHuntBtn.title = '';
            } else {
                elements.startHuntBtn.disabled = true;
                elements.startHuntBtn.title = 'All criteria must pass before starting hunt';
            }
        }
        
        // Build criteria breakdown HTML
        const criteriaHtml = formatJudgeCriteriaDisplay(criteria);
        
        // Build status message
        let statusMessage = '';
        if (hasMissingCriteria) {
            const missingIds = missingCriteria.map(([id]) => id).join(', ');
            statusMessage = `‚ö†Ô∏è Saved but MISSING CRITERIA: ${missingIds} - Please add them back to response_reference and re-judge`;
        } else if (isPassing) {
            statusMessage = '‚úÖ Saved & ALL CRITERIA PASS - Hunt Enabled!';
        } else {
            statusMessage = '‚ùå Saved but CRITERIA FAILED - Edit & try again';
        }
        
        resultDiv.innerHTML = `
            <div style="padding: 1rem; background: var(--bg-primary); border-radius: 8px; border: 1px solid ${hasMissingCriteria ? 'var(--warning)' : (isPassing ? 'var(--success)' : 'var(--danger)')};">
                <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <span class="score-badge ${scoreClass}">${scoreEmoji} Score: ${data.score}</span>
                    <span style="font-weight: 600;">${statusMessage}</span>
                </div>
                
                <!-- Criteria Breakdown -->
                <div style="margin-top: 0.75rem;">
                    <label style="font-weight: 600; font-size: 0.9rem;">üìã Criteria Breakdown:</label>
                    ${criteriaHtml}
                </div>
                
                <div style="margin-top: 0.75rem;">
                    <label style="font-weight: 600; font-size: 0.9rem;">üìù Judge Explanation:</label>
                    <p style="margin-top: 0.25rem; font-size: 0.9rem; color: var(--text-secondary); white-space: pre-wrap;">${escapeHtml(data.explanation || 'No explanation provided')}</p>
                    ${missingCriteria && missingCriteria.length > 0 ? `
                    <div style="margin-top: 0.5rem; padding: 0.5rem; background: var(--warning-bg); border-left: 3px solid var(--warning); border-radius: 4px; font-size: 0.85rem;">
                        <strong>‚ö†Ô∏è Note:</strong> The judge's explanation above refers only to the criteria present in <code>response_reference</code> (${evaluatedCriteria.length} criteria evaluated). 
                        ${missingCriteria.length} criterion/criteria (${missingCriteria.map(([id]) => id).join(', ')}) ${missingCriteria.length === 1 ? 'is' : 'are'} missing from <code>response_reference</code> and ${missingCriteria.length === 1 ? 'was' : 'were'} not evaluated.
                    </div>
                    ` : ''}
                </div>
            </div>
        `;
        // Show result div below response editor (expands downward)
        resultDiv.classList.remove('hidden');
        // Keep response editor in view - don't scroll away from it
        const responseEditor = document.getElementById('responseEditor');
        if (responseEditor) {
            // Just ensure editor is visible, don't scroll to result
            responseEditor.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
        }
        
        const passCount = criteriaEntries.filter(([k, v]) => String(v).toUpperCase() === 'PASS').length;
        const totalCount = criteriaEntries.length;
        showToast(`Saved: ${passCount}/${totalCount} criteria pass (${isPassing ? 'HUNT ENABLED' : 'Fix required'})`, isPassing ? 'success' : 'warning');
        
    } catch (error) {
        showToast(`Error: ${error.message}`, 'error');
    } finally {
        btn.disabled = false;
        btn.textContent = 'üíæ Save Response';
    }
}


// ============== Initialize ==============

function init() {
    try { initTrainerRegistration(); } catch(e) { console.error('initTrainerRegistration failed:', e); }
    try { initTheme(); } catch(e) { console.error('initTheme failed:', e); }
    try { initTabs(); } catch(e) { console.error('initTabs failed:', e); }
    try { initFileUpload(); } catch(e) { console.error('initFileUpload failed:', e); }
    try { initPreviewTabs(); } catch(e) { console.error('initPreviewTabs failed:', e); }
    try { initEventListeners(); } catch(e) { console.error('initEventListeners failed:', e); }
    try { initHuntNumberControls(); } catch(e) { console.error('initHuntNumberControls failed:', e); }
    
    if (elements.startHuntBtn) {
        elements.startHuntBtn.disabled = true;
        elements.startHuntBtn.title = 'Validate the reference response first (click "Judge Reference Response")';
    }

    try { initializeProviderLogic(); } catch(e) { console.error('initializeProviderLogic failed:', e); }
    try { initMultiTurnListeners(); } catch(e) { console.error('initMultiTurnListeners failed:', e); }
    try { initCalibrationListeners(); } catch(e) { console.error('initCalibrationListeners failed:', e); }
    
    console.log('üî• Model Hunter initialized');
}

// Initialize Provider/Model selection logic
function initializeProviderLogic() {
    if (!elements.providerSelect || !elements.modelSelect) return;

    // Set default provider to openrouter (has Qwen)
    if (elements.providerSelect) {
        elements.providerSelect.value = 'openrouter';
    }

    // Initial population (will select Qwen by default, but this can be overridden by notebook metadata)
    updateModelOptions();

    // Event listener
    elements.providerSelect.addEventListener('change', updateModelOptions);
}

function updateModelOptions(skipDefaultSelection = false) {
    const provider = elements.providerSelect.value;
    const models = PROVIDER_MODELS[provider] || [];
    
    // Clear current options
    elements.modelSelect.innerHTML = '';
    
    // Determine default model based on provider (only if skipDefaultSelection is false)
    let defaultModelId = 'qwen/qwen3-235b-a22b-thinking-2507'; // Default to Qwen
    if (provider === 'fireworks') {
        defaultModelId = 'accounts/fireworks/models/qwen3-235b-a22b-thinking-2507';
    }
    
    // Helper function to extract model key for comparison
    const getModelKey = (modelStr) => {
        const lower = (modelStr || '').toLowerCase();
        if (lower.includes('nemotron')) return 'nemotron';
        if (lower.includes('qwen')) return 'qwen';
        if (lower.includes('llama')) return 'llama';
        if (lower.includes('deepseek')) return 'deepseek';
        if (lower.includes('mistral')) return 'mistral';
        if (lower.includes('gpt')) return 'gpt';
        if (lower.includes('claude')) return 'claude';
        if (lower.includes('gemini')) return 'gemini';
        return lower.replace(/[^a-z0-9]/g, '');
    };
    
    // Add new options (all models enabled)
    models.forEach(model => {
        const option = document.createElement('option');
        option.value = model.id;
        option.textContent = model.name;
        
        if (!skipDefaultSelection) {
            // If a notebook preselected a model, honor that
            if (state._preselectedModelId && model.id === state._preselectedModelId) {
                option.selected = true;
            } else if (!state._preselectedModelId) {
                // No preselection ‚Äî default to Qwen
                if (model.id === defaultModelId || model.id.includes('qwen')) {
                    option.selected = true;
                }
            }
        }
        elements.modelSelect.appendChild(option);
    });
    
    // If no Qwen model was found and we're not skipping default, select first ENABLED model
    if (!skipDefaultSelection && models.length > 0) {
        // Check if current selection is disabled
        const currentOption = elements.modelSelect.querySelector(`option[value="${elements.modelSelect.value}"]`);
        if (!currentOption || currentOption.disabled) {
            // Select first enabled option
            const firstEnabled = Array.from(elements.modelSelect.options).find(opt => !opt.disabled);
            if (firstEnabled) {
                elements.modelSelect.value = firstEnabled.value;
            }
        }
    }
    
    // Update state config with selected model (only if we set a default)
    if (!skipDefaultSelection && elements.modelSelect.value) {
        state.config.models = [elements.modelSelect.value];
    }
    
    console.log(`Updated models for provider: ${provider}, selected: ${elements.modelSelect.value} (skipDefault: ${skipDefaultSelection})`);
}

// Restore session on page load
async function restoreSession() {
    const savedSessionId = localStorage.getItem('modelHunter_sessionId');
    if (!savedSessionId) {
        console.log('No saved session found');
        return;
    }
    
    console.log('üîÑ Attempting to restore session:', savedSessionId);
    
    try {
        // Try to get session from backend
        const response = await fetch(`/api/session/${savedSessionId}`);
        if (response.ok) {
            const sessionData = await response.json();
            console.log('‚úÖ Session restored:', sessionData);
            
            // Try to get full notebook data
            // We need to reconstruct the notebook from session storage
            // For now, show a message that they need to reload the notebook
            showToast('üîÑ Session found! Please reload the notebook to continue.', 'info');
            
            // Store sessionId in state
            state.sessionId = savedSessionId;
            
            // Optionally, try to fetch notebook data if available
            // This would require an endpoint to get notebook from session
        } else if (response.status === 404) {
            // Session expired or not found
            console.log('‚ö†Ô∏è Session expired or not found');
            localStorage.removeItem('modelHunter_sessionId');
            showToast('‚ö†Ô∏è Previous session expired. Please load a new notebook.', 'warning');
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    } catch (error) {
        console.error('Error restoring session:', error);
        localStorage.removeItem('modelHunter_sessionId');
    }
}

// Start app
document.addEventListener('DOMContentLoaded', async () => {
    await init();
    // Restore session after initialization
    await restoreSession();
    
    // Ensure fetch button is set up (backup in case init didn't catch it)
    const fetchBtn = document.getElementById('fetchUrlBtn');
    if (fetchBtn && !fetchBtn.onclick) {
        console.log('Setting up fetch button as backup...');
        fetchBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            console.log('Fetch button clicked (backup handler)');
            fetchFromUrl();
        });
        fetchBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            fetchFromUrl();
        };
        fetchBtn.type = 'button';
        fetchBtn.disabled = false;
    }
    
    // Upload section toggle (collapse/expand)
    const uploadToggle = document.getElementById('uploadToggleHeader');
    if (uploadToggle) {
        uploadToggle.addEventListener('click', () => {
            const body = document.getElementById('uploadBody');
            const chevron = document.getElementById('uploadChevron');
            if (body && chevron) {
                body.classList.toggle('collapsed');
                chevron.classList.toggle('collapsed');
            }
        });
    }
});
